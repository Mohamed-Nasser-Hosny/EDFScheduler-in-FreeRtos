
EDFScheduler.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000e5c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000e  00800060  00000e5c  00000ef0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000645  0080006e  0080006e  00000efe  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000efe  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000f30  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000200  00000000  00000000  00000f6c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000026ea  00000000  00000000  0000116c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000cc1  00000000  00000000  00003856  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000171e  00000000  00000000  00004517  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000005c8  00000000  00000000  00005c38  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000f44  00000000  00000000  00006200  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000020b3  00000000  00000000  00007144  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000228  00000000  00000000  000091f7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 29 02 	jmp	0x452	; 0x452 <__vector_7>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	ec e5       	ldi	r30, 0x5C	; 92
  68:	fe e0       	ldi	r31, 0x0E	; 14
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	ae 36       	cpi	r26, 0x6E	; 110
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	26 e0       	ldi	r18, 0x06	; 6
  78:	ae e6       	ldi	r26, 0x6E	; 110
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a3 3b       	cpi	r26, 0xB3	; 179
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 14 07 	call	0xe28	; 0xe28 <main>
  8a:	0c 94 2c 07 	jmp	0xe58	; 0xe58 <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
  92:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  94:	03 96       	adiw	r24, 0x03	; 3
  96:	92 83       	std	Z+2, r25	; 0x02
  98:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
  9a:	2f ef       	ldi	r18, 0xFF	; 255
  9c:	3f ef       	ldi	r19, 0xFF	; 255
  9e:	34 83       	std	Z+4, r19	; 0x04
  a0:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  a2:	96 83       	std	Z+6, r25	; 0x06
  a4:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  a6:	90 87       	std	Z+8, r25	; 0x08
  a8:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
  aa:	10 82       	st	Z, r1
  ac:	08 95       	ret

000000ae <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
  ae:	fc 01       	movw	r30, r24
  b0:	11 86       	std	Z+9, r1	; 0x09
  b2:	10 86       	std	Z+8, r1	; 0x08
  b4:	08 95       	ret

000000b6 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
  b6:	cf 93       	push	r28
  b8:	df 93       	push	r29
  ba:	9c 01       	movw	r18, r24
  bc:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
  be:	dc 01       	movw	r26, r24
  c0:	11 96       	adiw	r26, 0x01	; 1
  c2:	cd 91       	ld	r28, X+
  c4:	dc 91       	ld	r29, X
  c6:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
  c8:	d3 83       	std	Z+3, r29	; 0x03
  ca:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
  cc:	8c 81       	ldd	r24, Y+4	; 0x04
  ce:	9d 81       	ldd	r25, Y+5	; 0x05
  d0:	95 83       	std	Z+5, r25	; 0x05
  d2:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
  d4:	8c 81       	ldd	r24, Y+4	; 0x04
  d6:	9d 81       	ldd	r25, Y+5	; 0x05
  d8:	dc 01       	movw	r26, r24
  da:	13 96       	adiw	r26, 0x03	; 3
  dc:	7c 93       	st	X, r23
  de:	6e 93       	st	-X, r22
  e0:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
  e2:	7d 83       	std	Y+5, r23	; 0x05
  e4:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
  e6:	31 87       	std	Z+9, r19	; 0x09
  e8:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
  ea:	f9 01       	movw	r30, r18
  ec:	80 81       	ld	r24, Z
  ee:	8f 5f       	subi	r24, 0xFF	; 255
  f0:	80 83       	st	Z, r24
}
  f2:	df 91       	pop	r29
  f4:	cf 91       	pop	r28
  f6:	08 95       	ret

000000f8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
  f8:	cf 93       	push	r28
  fa:	df 93       	push	r29
  fc:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
  fe:	48 81       	ld	r20, Y
 100:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 102:	4f 3f       	cpi	r20, 0xFF	; 255
 104:	2f ef       	ldi	r18, 0xFF	; 255
 106:	52 07       	cpc	r21, r18
 108:	21 f4       	brne	.+8      	; 0x112 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 10a:	fc 01       	movw	r30, r24
 10c:	a7 81       	ldd	r26, Z+7	; 0x07
 10e:	b0 85       	ldd	r27, Z+8	; 0x08
 110:	0d c0       	rjmp	.+26     	; 0x12c <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 112:	dc 01       	movw	r26, r24
 114:	13 96       	adiw	r26, 0x03	; 3
 116:	01 c0       	rjmp	.+2      	; 0x11a <vListInsert+0x22>
 118:	df 01       	movw	r26, r30
 11a:	12 96       	adiw	r26, 0x02	; 2
 11c:	ed 91       	ld	r30, X+
 11e:	fc 91       	ld	r31, X
 120:	13 97       	sbiw	r26, 0x03	; 3
 122:	20 81       	ld	r18, Z
 124:	31 81       	ldd	r19, Z+1	; 0x01
 126:	42 17       	cp	r20, r18
 128:	53 07       	cpc	r21, r19
 12a:	b0 f7       	brcc	.-20     	; 0x118 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 12c:	12 96       	adiw	r26, 0x02	; 2
 12e:	ed 91       	ld	r30, X+
 130:	fc 91       	ld	r31, X
 132:	13 97       	sbiw	r26, 0x03	; 3
 134:	fb 83       	std	Y+3, r31	; 0x03
 136:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 138:	d5 83       	std	Z+5, r29	; 0x05
 13a:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
 13c:	bd 83       	std	Y+5, r27	; 0x05
 13e:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
 140:	13 96       	adiw	r26, 0x03	; 3
 142:	dc 93       	st	X, r29
 144:	ce 93       	st	-X, r28
 146:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 148:	99 87       	std	Y+9, r25	; 0x09
 14a:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
 14c:	fc 01       	movw	r30, r24
 14e:	20 81       	ld	r18, Z
 150:	2f 5f       	subi	r18, 0xFF	; 255
 152:	20 83       	st	Z, r18
}
 154:	df 91       	pop	r29
 156:	cf 91       	pop	r28
 158:	08 95       	ret

0000015a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 15a:	cf 93       	push	r28
 15c:	df 93       	push	r29
 15e:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 160:	a0 85       	ldd	r26, Z+8	; 0x08
 162:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 164:	c2 81       	ldd	r28, Z+2	; 0x02
 166:	d3 81       	ldd	r29, Z+3	; 0x03
 168:	84 81       	ldd	r24, Z+4	; 0x04
 16a:	95 81       	ldd	r25, Z+5	; 0x05
 16c:	9d 83       	std	Y+5, r25	; 0x05
 16e:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 170:	c4 81       	ldd	r28, Z+4	; 0x04
 172:	d5 81       	ldd	r29, Z+5	; 0x05
 174:	82 81       	ldd	r24, Z+2	; 0x02
 176:	93 81       	ldd	r25, Z+3	; 0x03
 178:	9b 83       	std	Y+3, r25	; 0x03
 17a:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 17c:	11 96       	adiw	r26, 0x01	; 1
 17e:	8d 91       	ld	r24, X+
 180:	9c 91       	ld	r25, X
 182:	12 97       	sbiw	r26, 0x02	; 2
 184:	e8 17       	cp	r30, r24
 186:	f9 07       	cpc	r31, r25
 188:	31 f4       	brne	.+12     	; 0x196 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 18a:	84 81       	ldd	r24, Z+4	; 0x04
 18c:	95 81       	ldd	r25, Z+5	; 0x05
 18e:	12 96       	adiw	r26, 0x02	; 2
 190:	9c 93       	st	X, r25
 192:	8e 93       	st	-X, r24
 194:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 196:	11 86       	std	Z+9, r1	; 0x09
 198:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 19a:	8c 91       	ld	r24, X
 19c:	81 50       	subi	r24, 0x01	; 1
 19e:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
 1a0:	df 91       	pop	r29
 1a2:	cf 91       	pop	r28
 1a4:	08 95       	ret

000001a6 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 1a6:	31 e1       	ldi	r19, 0x11	; 17
 1a8:	fc 01       	movw	r30, r24
 1aa:	30 83       	st	Z, r19
 1ac:	31 97       	sbiw	r30, 0x01	; 1
 1ae:	22 e2       	ldi	r18, 0x22	; 34
 1b0:	20 83       	st	Z, r18
 1b2:	31 97       	sbiw	r30, 0x01	; 1
 1b4:	a3 e3       	ldi	r26, 0x33	; 51
 1b6:	a0 83       	st	Z, r26
 1b8:	31 97       	sbiw	r30, 0x01	; 1
 1ba:	60 83       	st	Z, r22
 1bc:	31 97       	sbiw	r30, 0x01	; 1
 1be:	70 83       	st	Z, r23
 1c0:	31 97       	sbiw	r30, 0x01	; 1
 1c2:	10 82       	st	Z, r1
 1c4:	31 97       	sbiw	r30, 0x01	; 1
 1c6:	60 e8       	ldi	r22, 0x80	; 128
 1c8:	60 83       	st	Z, r22
 1ca:	31 97       	sbiw	r30, 0x01	; 1
 1cc:	10 82       	st	Z, r1
 1ce:	31 97       	sbiw	r30, 0x01	; 1
 1d0:	62 e0       	ldi	r22, 0x02	; 2
 1d2:	60 83       	st	Z, r22
 1d4:	31 97       	sbiw	r30, 0x01	; 1
 1d6:	63 e0       	ldi	r22, 0x03	; 3
 1d8:	60 83       	st	Z, r22
 1da:	31 97       	sbiw	r30, 0x01	; 1
 1dc:	64 e0       	ldi	r22, 0x04	; 4
 1de:	60 83       	st	Z, r22
 1e0:	31 97       	sbiw	r30, 0x01	; 1
 1e2:	65 e0       	ldi	r22, 0x05	; 5
 1e4:	60 83       	st	Z, r22
 1e6:	31 97       	sbiw	r30, 0x01	; 1
 1e8:	66 e0       	ldi	r22, 0x06	; 6
 1ea:	60 83       	st	Z, r22
 1ec:	31 97       	sbiw	r30, 0x01	; 1
 1ee:	67 e0       	ldi	r22, 0x07	; 7
 1f0:	60 83       	st	Z, r22
 1f2:	31 97       	sbiw	r30, 0x01	; 1
 1f4:	68 e0       	ldi	r22, 0x08	; 8
 1f6:	60 83       	st	Z, r22
 1f8:	31 97       	sbiw	r30, 0x01	; 1
 1fa:	69 e0       	ldi	r22, 0x09	; 9
 1fc:	60 83       	st	Z, r22
 1fe:	31 97       	sbiw	r30, 0x01	; 1
 200:	60 e1       	ldi	r22, 0x10	; 16
 202:	60 83       	st	Z, r22
 204:	31 97       	sbiw	r30, 0x01	; 1
 206:	30 83       	st	Z, r19
 208:	31 97       	sbiw	r30, 0x01	; 1
 20a:	32 e1       	ldi	r19, 0x12	; 18
 20c:	30 83       	st	Z, r19
 20e:	31 97       	sbiw	r30, 0x01	; 1
 210:	33 e1       	ldi	r19, 0x13	; 19
 212:	30 83       	st	Z, r19
 214:	31 97       	sbiw	r30, 0x01	; 1
 216:	34 e1       	ldi	r19, 0x14	; 20
 218:	30 83       	st	Z, r19
 21a:	31 97       	sbiw	r30, 0x01	; 1
 21c:	35 e1       	ldi	r19, 0x15	; 21
 21e:	30 83       	st	Z, r19
 220:	31 97       	sbiw	r30, 0x01	; 1
 222:	36 e1       	ldi	r19, 0x16	; 22
 224:	30 83       	st	Z, r19
 226:	31 97       	sbiw	r30, 0x01	; 1
 228:	37 e1       	ldi	r19, 0x17	; 23
 22a:	30 83       	st	Z, r19
 22c:	31 97       	sbiw	r30, 0x01	; 1
 22e:	38 e1       	ldi	r19, 0x18	; 24
 230:	30 83       	st	Z, r19
 232:	31 97       	sbiw	r30, 0x01	; 1
 234:	39 e1       	ldi	r19, 0x19	; 25
 236:	30 83       	st	Z, r19
 238:	31 97       	sbiw	r30, 0x01	; 1
 23a:	30 e2       	ldi	r19, 0x20	; 32
 23c:	30 83       	st	Z, r19
 23e:	31 97       	sbiw	r30, 0x01	; 1
 240:	31 e2       	ldi	r19, 0x21	; 33
 242:	30 83       	st	Z, r19
 244:	31 97       	sbiw	r30, 0x01	; 1
 246:	20 83       	st	Z, r18
 248:	31 97       	sbiw	r30, 0x01	; 1
 24a:	23 e2       	ldi	r18, 0x23	; 35
 24c:	20 83       	st	Z, r18
 24e:	31 97       	sbiw	r30, 0x01	; 1
 250:	40 83       	st	Z, r20
 252:	31 97       	sbiw	r30, 0x01	; 1
 254:	50 83       	st	Z, r21
 256:	31 97       	sbiw	r30, 0x01	; 1
 258:	26 e2       	ldi	r18, 0x26	; 38
 25a:	20 83       	st	Z, r18
 25c:	31 97       	sbiw	r30, 0x01	; 1
 25e:	27 e2       	ldi	r18, 0x27	; 39
 260:	20 83       	st	Z, r18
 262:	31 97       	sbiw	r30, 0x01	; 1
 264:	28 e2       	ldi	r18, 0x28	; 40
 266:	20 83       	st	Z, r18
 268:	31 97       	sbiw	r30, 0x01	; 1
 26a:	29 e2       	ldi	r18, 0x29	; 41
 26c:	20 83       	st	Z, r18
 26e:	31 97       	sbiw	r30, 0x01	; 1
 270:	20 e3       	ldi	r18, 0x30	; 48
 272:	20 83       	st	Z, r18
 274:	31 97       	sbiw	r30, 0x01	; 1
 276:	21 e3       	ldi	r18, 0x31	; 49
 278:	20 83       	st	Z, r18
 27a:	86 97       	sbiw	r24, 0x26	; 38
 27c:	08 95       	ret

0000027e <xPortStartScheduler>:
 27e:	1b bc       	out	0x2b, r1	; 43
 280:	89 ef       	ldi	r24, 0xF9	; 249
 282:	8a bd       	out	0x2a, r24	; 42
 284:	8b e0       	ldi	r24, 0x0B	; 11
 286:	8e bd       	out	0x2e, r24	; 46
 288:	89 b7       	in	r24, 0x39	; 57
 28a:	80 61       	ori	r24, 0x10	; 16
 28c:	89 bf       	out	0x39, r24	; 57
 28e:	a0 91 af 06 	lds	r26, 0x06AF	; 0x8006af <pxCurrentTCB>
 292:	b0 91 b0 06 	lds	r27, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
 296:	cd 91       	ld	r28, X+
 298:	cd bf       	out	0x3d, r28	; 61
 29a:	dd 91       	ld	r29, X+
 29c:	de bf       	out	0x3e, r29	; 62
 29e:	ff 91       	pop	r31
 2a0:	ef 91       	pop	r30
 2a2:	df 91       	pop	r29
 2a4:	cf 91       	pop	r28
 2a6:	bf 91       	pop	r27
 2a8:	af 91       	pop	r26
 2aa:	9f 91       	pop	r25
 2ac:	8f 91       	pop	r24
 2ae:	7f 91       	pop	r23
 2b0:	6f 91       	pop	r22
 2b2:	5f 91       	pop	r21
 2b4:	4f 91       	pop	r20
 2b6:	3f 91       	pop	r19
 2b8:	2f 91       	pop	r18
 2ba:	1f 91       	pop	r17
 2bc:	0f 91       	pop	r16
 2be:	ff 90       	pop	r15
 2c0:	ef 90       	pop	r14
 2c2:	df 90       	pop	r13
 2c4:	cf 90       	pop	r12
 2c6:	bf 90       	pop	r11
 2c8:	af 90       	pop	r10
 2ca:	9f 90       	pop	r9
 2cc:	8f 90       	pop	r8
 2ce:	7f 90       	pop	r7
 2d0:	6f 90       	pop	r6
 2d2:	5f 90       	pop	r5
 2d4:	4f 90       	pop	r4
 2d6:	3f 90       	pop	r3
 2d8:	2f 90       	pop	r2
 2da:	1f 90       	pop	r1
 2dc:	0f 90       	pop	r0
 2de:	0f be       	out	0x3f, r0	; 63
 2e0:	0f 90       	pop	r0
 2e2:	08 95       	ret
 2e4:	81 e0       	ldi	r24, 0x01	; 1
 2e6:	08 95       	ret

000002e8 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 2e8:	0f 92       	push	r0
 2ea:	0f b6       	in	r0, 0x3f	; 63
 2ec:	f8 94       	cli
 2ee:	0f 92       	push	r0
 2f0:	1f 92       	push	r1
 2f2:	11 24       	eor	r1, r1
 2f4:	2f 92       	push	r2
 2f6:	3f 92       	push	r3
 2f8:	4f 92       	push	r4
 2fa:	5f 92       	push	r5
 2fc:	6f 92       	push	r6
 2fe:	7f 92       	push	r7
 300:	8f 92       	push	r8
 302:	9f 92       	push	r9
 304:	af 92       	push	r10
 306:	bf 92       	push	r11
 308:	cf 92       	push	r12
 30a:	df 92       	push	r13
 30c:	ef 92       	push	r14
 30e:	ff 92       	push	r15
 310:	0f 93       	push	r16
 312:	1f 93       	push	r17
 314:	2f 93       	push	r18
 316:	3f 93       	push	r19
 318:	4f 93       	push	r20
 31a:	5f 93       	push	r21
 31c:	6f 93       	push	r22
 31e:	7f 93       	push	r23
 320:	8f 93       	push	r24
 322:	9f 93       	push	r25
 324:	af 93       	push	r26
 326:	bf 93       	push	r27
 328:	cf 93       	push	r28
 32a:	df 93       	push	r29
 32c:	ef 93       	push	r30
 32e:	ff 93       	push	r31
 330:	a0 91 af 06 	lds	r26, 0x06AF	; 0x8006af <pxCurrentTCB>
 334:	b0 91 b0 06 	lds	r27, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
 338:	0d b6       	in	r0, 0x3d	; 61
 33a:	0d 92       	st	X+, r0
 33c:	0e b6       	in	r0, 0x3e	; 62
 33e:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 340:	0e 94 9d 06 	call	0xd3a	; 0xd3a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 344:	a0 91 af 06 	lds	r26, 0x06AF	; 0x8006af <pxCurrentTCB>
 348:	b0 91 b0 06 	lds	r27, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
 34c:	cd 91       	ld	r28, X+
 34e:	cd bf       	out	0x3d, r28	; 61
 350:	dd 91       	ld	r29, X+
 352:	de bf       	out	0x3e, r29	; 62
 354:	ff 91       	pop	r31
 356:	ef 91       	pop	r30
 358:	df 91       	pop	r29
 35a:	cf 91       	pop	r28
 35c:	bf 91       	pop	r27
 35e:	af 91       	pop	r26
 360:	9f 91       	pop	r25
 362:	8f 91       	pop	r24
 364:	7f 91       	pop	r23
 366:	6f 91       	pop	r22
 368:	5f 91       	pop	r21
 36a:	4f 91       	pop	r20
 36c:	3f 91       	pop	r19
 36e:	2f 91       	pop	r18
 370:	1f 91       	pop	r17
 372:	0f 91       	pop	r16
 374:	ff 90       	pop	r15
 376:	ef 90       	pop	r14
 378:	df 90       	pop	r13
 37a:	cf 90       	pop	r12
 37c:	bf 90       	pop	r11
 37e:	af 90       	pop	r10
 380:	9f 90       	pop	r9
 382:	8f 90       	pop	r8
 384:	7f 90       	pop	r7
 386:	6f 90       	pop	r6
 388:	5f 90       	pop	r5
 38a:	4f 90       	pop	r4
 38c:	3f 90       	pop	r3
 38e:	2f 90       	pop	r2
 390:	1f 90       	pop	r1
 392:	0f 90       	pop	r0
 394:	0f be       	out	0x3f, r0	; 63
 396:	0f 90       	pop	r0

	asm volatile ( "ret" );
 398:	08 95       	ret

0000039a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 39a:	0f 92       	push	r0
 39c:	0f b6       	in	r0, 0x3f	; 63
 39e:	f8 94       	cli
 3a0:	0f 92       	push	r0
 3a2:	1f 92       	push	r1
 3a4:	11 24       	eor	r1, r1
 3a6:	2f 92       	push	r2
 3a8:	3f 92       	push	r3
 3aa:	4f 92       	push	r4
 3ac:	5f 92       	push	r5
 3ae:	6f 92       	push	r6
 3b0:	7f 92       	push	r7
 3b2:	8f 92       	push	r8
 3b4:	9f 92       	push	r9
 3b6:	af 92       	push	r10
 3b8:	bf 92       	push	r11
 3ba:	cf 92       	push	r12
 3bc:	df 92       	push	r13
 3be:	ef 92       	push	r14
 3c0:	ff 92       	push	r15
 3c2:	0f 93       	push	r16
 3c4:	1f 93       	push	r17
 3c6:	2f 93       	push	r18
 3c8:	3f 93       	push	r19
 3ca:	4f 93       	push	r20
 3cc:	5f 93       	push	r21
 3ce:	6f 93       	push	r22
 3d0:	7f 93       	push	r23
 3d2:	8f 93       	push	r24
 3d4:	9f 93       	push	r25
 3d6:	af 93       	push	r26
 3d8:	bf 93       	push	r27
 3da:	cf 93       	push	r28
 3dc:	df 93       	push	r29
 3de:	ef 93       	push	r30
 3e0:	ff 93       	push	r31
 3e2:	a0 91 af 06 	lds	r26, 0x06AF	; 0x8006af <pxCurrentTCB>
 3e6:	b0 91 b0 06 	lds	r27, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
 3ea:	0d b6       	in	r0, 0x3d	; 61
 3ec:	0d 92       	st	X+, r0
 3ee:	0e b6       	in	r0, 0x3e	; 62
 3f0:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
 3f2:	0e 94 01 05 	call	0xa02	; 0xa02 <xTaskIncrementTick>
 3f6:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
 3f8:	0e 94 9d 06 	call	0xd3a	; 0xd3a <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
 3fc:	a0 91 af 06 	lds	r26, 0x06AF	; 0x8006af <pxCurrentTCB>
 400:	b0 91 b0 06 	lds	r27, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
 404:	cd 91       	ld	r28, X+
 406:	cd bf       	out	0x3d, r28	; 61
 408:	dd 91       	ld	r29, X+
 40a:	de bf       	out	0x3e, r29	; 62
 40c:	ff 91       	pop	r31
 40e:	ef 91       	pop	r30
 410:	df 91       	pop	r29
 412:	cf 91       	pop	r28
 414:	bf 91       	pop	r27
 416:	af 91       	pop	r26
 418:	9f 91       	pop	r25
 41a:	8f 91       	pop	r24
 41c:	7f 91       	pop	r23
 41e:	6f 91       	pop	r22
 420:	5f 91       	pop	r21
 422:	4f 91       	pop	r20
 424:	3f 91       	pop	r19
 426:	2f 91       	pop	r18
 428:	1f 91       	pop	r17
 42a:	0f 91       	pop	r16
 42c:	ff 90       	pop	r15
 42e:	ef 90       	pop	r14
 430:	df 90       	pop	r13
 432:	cf 90       	pop	r12
 434:	bf 90       	pop	r11
 436:	af 90       	pop	r10
 438:	9f 90       	pop	r9
 43a:	8f 90       	pop	r8
 43c:	7f 90       	pop	r7
 43e:	6f 90       	pop	r6
 440:	5f 90       	pop	r5
 442:	4f 90       	pop	r4
 444:	3f 90       	pop	r3
 446:	2f 90       	pop	r2
 448:	1f 90       	pop	r1
 44a:	0f 90       	pop	r0
 44c:	0f be       	out	0x3f, r0	; 63
 44e:	0f 90       	pop	r0

	asm volatile ( "ret" );
 450:	08 95       	ret

00000452 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
 452:	0e 94 cd 01 	call	0x39a	; 0x39a <vPortYieldFromTick>
		asm volatile ( "reti" );
 456:	18 95       	reti

00000458 <prvInsertBlockIntoFreeList>:
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
 458:	cf 93       	push	r28
 45a:	df 93       	push	r29
 45c:	dc 01       	movw	r26, r24
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 45e:	e6 e7       	ldi	r30, 0x76	; 118
 460:	f0 e0       	ldi	r31, 0x00	; 0
 462:	01 c0       	rjmp	.+2      	; 0x466 <prvInsertBlockIntoFreeList+0xe>
 464:	f9 01       	movw	r30, r18
 466:	20 81       	ld	r18, Z
 468:	31 81       	ldd	r19, Z+1	; 0x01
 46a:	2a 17       	cp	r18, r26
 46c:	3b 07       	cpc	r19, r27
 46e:	d0 f3       	brcs	.-12     	; 0x464 <prvInsertBlockIntoFreeList+0xc>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 470:	82 81       	ldd	r24, Z+2	; 0x02
 472:	93 81       	ldd	r25, Z+3	; 0x03
 474:	af 01       	movw	r20, r30
 476:	48 0f       	add	r20, r24
 478:	59 1f       	adc	r21, r25
 47a:	a4 17       	cp	r26, r20
 47c:	b5 07       	cpc	r27, r21
 47e:	49 f4       	brne	.+18     	; 0x492 <prvInsertBlockIntoFreeList+0x3a>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 480:	12 96       	adiw	r26, 0x02	; 2
 482:	4d 91       	ld	r20, X+
 484:	5c 91       	ld	r21, X
 486:	13 97       	sbiw	r26, 0x03	; 3
 488:	84 0f       	add	r24, r20
 48a:	95 1f       	adc	r25, r21
 48c:	93 83       	std	Z+3, r25	; 0x03
 48e:	82 83       	std	Z+2, r24	; 0x02
 490:	df 01       	movw	r26, r30
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 492:	12 96       	adiw	r26, 0x02	; 2
 494:	8d 91       	ld	r24, X+
 496:	9c 91       	ld	r25, X
 498:	13 97       	sbiw	r26, 0x03	; 3
 49a:	ed 01       	movw	r28, r26
 49c:	c8 0f       	add	r28, r24
 49e:	d9 1f       	adc	r29, r25
 4a0:	2c 17       	cp	r18, r28
 4a2:	3d 07       	cpc	r19, r29
 4a4:	d9 f4       	brne	.+54     	; 0x4dc <prvInsertBlockIntoFreeList+0x84>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 4a6:	20 91 74 00 	lds	r18, 0x0074	; 0x800074 <pxEnd>
 4aa:	30 91 75 00 	lds	r19, 0x0075	; 0x800075 <pxEnd+0x1>
 4ae:	c2 17       	cp	r28, r18
 4b0:	d3 07       	cpc	r29, r19
 4b2:	81 f0       	breq	.+32     	; 0x4d4 <prvInsertBlockIntoFreeList+0x7c>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 4b4:	2a 81       	ldd	r18, Y+2	; 0x02
 4b6:	3b 81       	ldd	r19, Y+3	; 0x03
 4b8:	82 0f       	add	r24, r18
 4ba:	93 1f       	adc	r25, r19
 4bc:	13 96       	adiw	r26, 0x03	; 3
 4be:	9c 93       	st	X, r25
 4c0:	8e 93       	st	-X, r24
 4c2:	12 97       	sbiw	r26, 0x02	; 2
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 4c4:	c0 81       	ld	r28, Z
 4c6:	d1 81       	ldd	r29, Z+1	; 0x01
 4c8:	88 81       	ld	r24, Y
 4ca:	99 81       	ldd	r25, Y+1	; 0x01
 4cc:	11 96       	adiw	r26, 0x01	; 1
 4ce:	9c 93       	st	X, r25
 4d0:	8e 93       	st	-X, r24
 4d2:	07 c0       	rjmp	.+14     	; 0x4e2 <prvInsertBlockIntoFreeList+0x8a>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
 4d4:	11 96       	adiw	r26, 0x01	; 1
 4d6:	dc 93       	st	X, r29
 4d8:	ce 93       	st	-X, r28
 4da:	03 c0       	rjmp	.+6      	; 0x4e2 <prvInsertBlockIntoFreeList+0x8a>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 4dc:	11 96       	adiw	r26, 0x01	; 1
 4de:	3c 93       	st	X, r19
 4e0:	2e 93       	st	-X, r18

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 4e2:	ae 17       	cp	r26, r30
 4e4:	bf 07       	cpc	r27, r31
 4e6:	11 f0       	breq	.+4      	; 0x4ec <prvInsertBlockIntoFreeList+0x94>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 4e8:	b1 83       	std	Z+1, r27	; 0x01
 4ea:	a0 83       	st	Z, r26
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 4ec:	df 91       	pop	r29
 4ee:	cf 91       	pop	r28
 4f0:	08 95       	ret

000004f2 <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 4f2:	cf 92       	push	r12
 4f4:	df 92       	push	r13
 4f6:	ef 92       	push	r14
 4f8:	ff 92       	push	r15
 4fa:	0f 93       	push	r16
 4fc:	1f 93       	push	r17
 4fe:	cf 93       	push	r28
 500:	df 93       	push	r29
 502:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
 504:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
 508:	80 91 74 00 	lds	r24, 0x0074	; 0x800074 <pxEnd>
 50c:	90 91 75 00 	lds	r25, 0x0075	; 0x800075 <pxEnd+0x1>
 510:	89 2b       	or	r24, r25
 512:	41 f5       	brne	.+80     	; 0x564 <pvPortMalloc+0x72>

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 514:	e6 e7       	ldi	r30, 0x76	; 118
 516:	f0 e0       	ldi	r31, 0x00	; 0
 518:	aa e7       	ldi	r26, 0x7A	; 122
 51a:	b0 e0       	ldi	r27, 0x00	; 0
 51c:	b1 83       	std	Z+1, r27	; 0x01
 51e:	a0 83       	st	Z, r26
	xStart.xBlockSize = ( size_t ) 0;
 520:	13 82       	std	Z+3, r1	; 0x03
 522:	12 82       	std	Z+2, r1	; 0x02
	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
	uxAddress -= xHeapStructSize;
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
	pxEnd = ( void * ) uxAddress;
 524:	e2 e5       	ldi	r30, 0x52	; 82
 526:	f6 e0       	ldi	r31, 0x06	; 6
 528:	f0 93 75 00 	sts	0x0075, r31	; 0x800075 <pxEnd+0x1>
 52c:	e0 93 74 00 	sts	0x0074, r30	; 0x800074 <pxEnd>
	pxEnd->xBlockSize = 0;
 530:	13 82       	std	Z+3, r1	; 0x03
 532:	12 82       	std	Z+2, r1	; 0x02
	pxEnd->pxNextFreeBlock = NULL;
 534:	11 82       	std	Z+1, r1	; 0x01
 536:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 538:	88 ed       	ldi	r24, 0xD8	; 216
 53a:	95 e0       	ldi	r25, 0x05	; 5
 53c:	13 96       	adiw	r26, 0x03	; 3
 53e:	9c 93       	st	X, r25
 540:	8e 93       	st	-X, r24
 542:	12 97       	sbiw	r26, 0x02	; 2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 544:	ed 93       	st	X+, r30
 546:	fc 93       	st	X, r31

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 548:	90 93 71 00 	sts	0x0071, r25	; 0x800071 <xMinimumEverFreeBytesRemaining+0x1>
 54c:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <xMinimumEverFreeBytesRemaining>
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 550:	90 93 73 00 	sts	0x0073, r25	; 0x800073 <xFreeBytesRemaining+0x1>
 554:	80 93 72 00 	sts	0x0072, r24	; 0x800072 <xFreeBytesRemaining>

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 558:	80 e0       	ldi	r24, 0x00	; 0
 55a:	90 e8       	ldi	r25, 0x80	; 128
 55c:	90 93 6f 00 	sts	0x006F, r25	; 0x80006f <__data_end+0x1>
 560:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__data_end>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 564:	e0 90 6e 00 	lds	r14, 0x006E	; 0x80006e <__data_end>
 568:	f0 90 6f 00 	lds	r15, 0x006F	; 0x80006f <__data_end+0x1>
 56c:	c7 01       	movw	r24, r14
 56e:	8c 23       	and	r24, r28
 570:	9d 23       	and	r25, r29
 572:	89 2b       	or	r24, r25
 574:	09 f0       	breq	.+2      	; 0x578 <pvPortMalloc+0x86>
 576:	5f c0       	rjmp	.+190    	; 0x636 <pvPortMalloc+0x144>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
 578:	20 97       	sbiw	r28, 0x00	; 0
 57a:	09 f4       	brne	.+2      	; 0x57e <pvPortMalloc+0x8c>
 57c:	5f c0       	rjmp	.+190    	; 0x63c <pvPortMalloc+0x14a>
			{
				xWantedSize += xHeapStructSize;
 57e:	ae 01       	movw	r20, r28
 580:	4c 5f       	subi	r20, 0xFC	; 252
 582:	5f 4f       	sbci	r21, 0xFF	; 255
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 584:	09 f4       	brne	.+2      	; 0x588 <pvPortMalloc+0x96>
 586:	5d c0       	rjmp	.+186    	; 0x642 <pvPortMalloc+0x150>
 588:	00 91 72 00 	lds	r16, 0x0072	; 0x800072 <xFreeBytesRemaining>
 58c:	10 91 73 00 	lds	r17, 0x0073	; 0x800073 <xFreeBytesRemaining+0x1>
 590:	04 17       	cp	r16, r20
 592:	15 07       	cpc	r17, r21
 594:	08 f4       	brcc	.+2      	; 0x598 <pvPortMalloc+0xa6>
 596:	58 c0       	rjmp	.+176    	; 0x648 <pvPortMalloc+0x156>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
 598:	c0 91 76 00 	lds	r28, 0x0076	; 0x800076 <xStart>
 59c:	d0 91 77 00 	lds	r29, 0x0077	; 0x800077 <xStart+0x1>

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
 5a0:	e6 e7       	ldi	r30, 0x76	; 118
 5a2:	f0 e0       	ldi	r31, 0x00	; 0
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 5a4:	02 c0       	rjmp	.+4      	; 0x5aa <pvPortMalloc+0xb8>
 5a6:	fe 01       	movw	r30, r28
				{
					pxPreviousBlock = pxBlock;
					pxBlock = pxBlock->pxNextFreeBlock;
 5a8:	e9 01       	movw	r28, r18
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 5aa:	2a 81       	ldd	r18, Y+2	; 0x02
 5ac:	3b 81       	ldd	r19, Y+3	; 0x03
 5ae:	24 17       	cp	r18, r20
 5b0:	35 07       	cpc	r19, r21
 5b2:	28 f4       	brcc	.+10     	; 0x5be <pvPortMalloc+0xcc>
 5b4:	28 81       	ld	r18, Y
 5b6:	39 81       	ldd	r19, Y+1	; 0x01
 5b8:	21 15       	cp	r18, r1
 5ba:	31 05       	cpc	r19, r1
 5bc:	a1 f7       	brne	.-24     	; 0x5a6 <pvPortMalloc+0xb4>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
 5be:	80 91 74 00 	lds	r24, 0x0074	; 0x800074 <pxEnd>
 5c2:	90 91 75 00 	lds	r25, 0x0075	; 0x800075 <pxEnd+0x1>
 5c6:	c8 17       	cp	r28, r24
 5c8:	d9 07       	cpc	r29, r25
 5ca:	09 f4       	brne	.+2      	; 0x5ce <pvPortMalloc+0xdc>
 5cc:	40 c0       	rjmp	.+128    	; 0x64e <pvPortMalloc+0x15c>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 5ce:	c0 80       	ld	r12, Z
 5d0:	d1 80       	ldd	r13, Z+1	; 0x01
 5d2:	84 e0       	ldi	r24, 0x04	; 4
 5d4:	c8 0e       	add	r12, r24
 5d6:	d1 1c       	adc	r13, r1

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 5d8:	88 81       	ld	r24, Y
 5da:	99 81       	ldd	r25, Y+1	; 0x01
 5dc:	91 83       	std	Z+1, r25	; 0x01
 5de:	80 83       	st	Z, r24

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 5e0:	2a 81       	ldd	r18, Y+2	; 0x02
 5e2:	3b 81       	ldd	r19, Y+3	; 0x03
 5e4:	24 1b       	sub	r18, r20
 5e6:	35 0b       	sbc	r19, r21
 5e8:	29 30       	cpi	r18, 0x09	; 9
 5ea:	31 05       	cpc	r19, r1
 5ec:	50 f0       	brcs	.+20     	; 0x602 <pvPortMalloc+0x110>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 5ee:	ce 01       	movw	r24, r28
 5f0:	84 0f       	add	r24, r20
 5f2:	95 1f       	adc	r25, r21
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 5f4:	fc 01       	movw	r30, r24
 5f6:	33 83       	std	Z+3, r19	; 0x03
 5f8:	22 83       	std	Z+2, r18	; 0x02
						pxBlock->xBlockSize = xWantedSize;
 5fa:	5b 83       	std	Y+3, r21	; 0x03
 5fc:	4a 83       	std	Y+2, r20	; 0x02

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 5fe:	0e 94 2c 02 	call	0x458	; 0x458 <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
 602:	8a 81       	ldd	r24, Y+2	; 0x02
 604:	9b 81       	ldd	r25, Y+3	; 0x03
 606:	08 1b       	sub	r16, r24
 608:	19 0b       	sbc	r17, r25
 60a:	10 93 73 00 	sts	0x0073, r17	; 0x800073 <xFreeBytesRemaining+0x1>
 60e:	00 93 72 00 	sts	0x0072, r16	; 0x800072 <xFreeBytesRemaining>

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 612:	20 91 70 00 	lds	r18, 0x0070	; 0x800070 <xMinimumEverFreeBytesRemaining>
 616:	30 91 71 00 	lds	r19, 0x0071	; 0x800071 <xMinimumEverFreeBytesRemaining+0x1>
 61a:	02 17       	cp	r16, r18
 61c:	13 07       	cpc	r17, r19
 61e:	20 f4       	brcc	.+8      	; 0x628 <pvPortMalloc+0x136>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 620:	10 93 71 00 	sts	0x0071, r17	; 0x800071 <xMinimumEverFreeBytesRemaining+0x1>
 624:	00 93 70 00 	sts	0x0070, r16	; 0x800070 <xMinimumEverFreeBytesRemaining>
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 628:	e8 2a       	or	r14, r24
 62a:	f9 2a       	or	r15, r25
 62c:	fb 82       	std	Y+3, r15	; 0x03
 62e:	ea 82       	std	Y+2, r14	; 0x02
					pxBlock->pxNextFreeBlock = NULL;
 630:	19 82       	std	Y+1, r1	; 0x01
 632:	18 82       	st	Y, r1
 634:	0e c0       	rjmp	.+28     	; 0x652 <pvPortMalloc+0x160>
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
 636:	c1 2c       	mov	r12, r1
 638:	d1 2c       	mov	r13, r1
 63a:	0b c0       	rjmp	.+22     	; 0x652 <pvPortMalloc+0x160>
 63c:	c1 2c       	mov	r12, r1
 63e:	d1 2c       	mov	r13, r1
 640:	08 c0       	rjmp	.+16     	; 0x652 <pvPortMalloc+0x160>
 642:	c1 2c       	mov	r12, r1
 644:	d1 2c       	mov	r13, r1
 646:	05 c0       	rjmp	.+10     	; 0x652 <pvPortMalloc+0x160>
 648:	c1 2c       	mov	r12, r1
 64a:	d1 2c       	mov	r13, r1
 64c:	02 c0       	rjmp	.+4      	; 0x652 <pvPortMalloc+0x160>
 64e:	c1 2c       	mov	r12, r1
 650:	d1 2c       	mov	r13, r1
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 652:	0e 94 be 05 	call	0xb7c	; 0xb7c <xTaskResumeAll>
	}
	#endif

	configASSERT( ( ( ( uint32_t ) pvReturn ) & portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
 656:	c6 01       	movw	r24, r12
 658:	df 91       	pop	r29
 65a:	cf 91       	pop	r28
 65c:	1f 91       	pop	r17
 65e:	0f 91       	pop	r16
 660:	ff 90       	pop	r15
 662:	ef 90       	pop	r14
 664:	df 90       	pop	r13
 666:	cf 90       	pop	r12
 668:	08 95       	ret

0000066a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 66a:	cf 93       	push	r28
 66c:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
 66e:	00 97       	sbiw	r24, 0x00	; 0
 670:	59 f1       	breq	.+86     	; 0x6c8 <vPortFree+0x5e>

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
		configASSERT( pxLink->pxNextFreeBlock == NULL );

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
 672:	fc 01       	movw	r30, r24
 674:	34 97       	sbiw	r30, 0x04	; 4
 676:	22 81       	ldd	r18, Z+2	; 0x02
 678:	33 81       	ldd	r19, Z+3	; 0x03
 67a:	40 91 6e 00 	lds	r20, 0x006E	; 0x80006e <__data_end>
 67e:	50 91 6f 00 	lds	r21, 0x006F	; 0x80006f <__data_end+0x1>
 682:	b9 01       	movw	r22, r18
 684:	64 23       	and	r22, r20
 686:	75 23       	and	r23, r21
 688:	67 2b       	or	r22, r23
 68a:	f1 f0       	breq	.+60     	; 0x6c8 <vPortFree+0x5e>
		{
			if( pxLink->pxNextFreeBlock == NULL )
 68c:	60 81       	ld	r22, Z
 68e:	71 81       	ldd	r23, Z+1	; 0x01
 690:	67 2b       	or	r22, r23
 692:	d1 f4       	brne	.+52     	; 0x6c8 <vPortFree+0x5e>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 694:	ef 01       	movw	r28, r30
 696:	40 95       	com	r20
 698:	50 95       	com	r21
 69a:	24 23       	and	r18, r20
 69c:	35 23       	and	r19, r21
 69e:	33 83       	std	Z+3, r19	; 0x03
 6a0:	22 83       	std	Z+2, r18	; 0x02

				vTaskSuspendAll();
 6a2:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
 6a6:	20 91 72 00 	lds	r18, 0x0072	; 0x800072 <xFreeBytesRemaining>
 6aa:	30 91 73 00 	lds	r19, 0x0073	; 0x800073 <xFreeBytesRemaining+0x1>
 6ae:	8a 81       	ldd	r24, Y+2	; 0x02
 6b0:	9b 81       	ldd	r25, Y+3	; 0x03
 6b2:	82 0f       	add	r24, r18
 6b4:	93 1f       	adc	r25, r19
 6b6:	90 93 73 00 	sts	0x0073, r25	; 0x800073 <xFreeBytesRemaining+0x1>
 6ba:	80 93 72 00 	sts	0x0072, r24	; 0x800072 <xFreeBytesRemaining>
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 6be:	ce 01       	movw	r24, r28
 6c0:	0e 94 2c 02 	call	0x458	; 0x458 <prvInsertBlockIntoFreeList>
				}
				( void ) xTaskResumeAll();
 6c4:	0e 94 be 05 	call	0xb7c	; 0xb7c <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
 6c8:	df 91       	pop	r29
 6ca:	cf 91       	pop	r28
 6cc:	08 95       	ret

000006ce <prvResetNextTaskUnblockTime>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 6ce:	e0 91 77 06 	lds	r30, 0x0677	; 0x800677 <pxDelayedTaskList>
 6d2:	f0 91 78 06 	lds	r31, 0x0678	; 0x800678 <pxDelayedTaskList+0x1>
 6d6:	80 81       	ld	r24, Z
 6d8:	81 11       	cpse	r24, r1
 6da:	07 c0       	rjmp	.+14     	; 0x6ea <prvResetNextTaskUnblockTime+0x1c>
 6dc:	8f ef       	ldi	r24, 0xFF	; 255
 6de:	9f ef       	ldi	r25, 0xFF	; 255
 6e0:	90 93 58 06 	sts	0x0658, r25	; 0x800658 <xNextTaskUnblockTime+0x1>
 6e4:	80 93 57 06 	sts	0x0657, r24	; 0x800657 <xNextTaskUnblockTime>
 6e8:	08 95       	ret
 6ea:	e0 91 77 06 	lds	r30, 0x0677	; 0x800677 <pxDelayedTaskList>
 6ee:	f0 91 78 06 	lds	r31, 0x0678	; 0x800678 <pxDelayedTaskList+0x1>
 6f2:	05 80       	ldd	r0, Z+5	; 0x05
 6f4:	f6 81       	ldd	r31, Z+6	; 0x06
 6f6:	e0 2d       	mov	r30, r0
 6f8:	06 80       	ldd	r0, Z+6	; 0x06
 6fa:	f7 81       	ldd	r31, Z+7	; 0x07
 6fc:	e0 2d       	mov	r30, r0
 6fe:	82 81       	ldd	r24, Z+2	; 0x02
 700:	93 81       	ldd	r25, Z+3	; 0x03
 702:	90 93 58 06 	sts	0x0658, r25	; 0x800658 <xNextTaskUnblockTime+0x1>
 706:	80 93 57 06 	sts	0x0657, r24	; 0x800657 <xNextTaskUnblockTime>
 70a:	08 95       	ret

0000070c <prvAddCurrentTaskToDelayedList>:
 70c:	cf 93       	push	r28
 70e:	df 93       	push	r29
 710:	ec 01       	movw	r28, r24
 712:	e0 91 af 06 	lds	r30, 0x06AF	; 0x8006af <pxCurrentTCB>
 716:	f0 91 b0 06 	lds	r31, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
 71a:	93 83       	std	Z+3, r25	; 0x03
 71c:	82 83       	std	Z+2, r24	; 0x02
 71e:	80 91 5f 06 	lds	r24, 0x065F	; 0x80065f <xTickCount>
 722:	90 91 60 06 	lds	r25, 0x0660	; 0x800660 <xTickCount+0x1>
 726:	c8 17       	cp	r28, r24
 728:	d9 07       	cpc	r29, r25
 72a:	68 f4       	brcc	.+26     	; 0x746 <prvAddCurrentTaskToDelayedList+0x3a>
 72c:	60 91 af 06 	lds	r22, 0x06AF	; 0x8006af <pxCurrentTCB>
 730:	70 91 b0 06 	lds	r23, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
 734:	80 91 75 06 	lds	r24, 0x0675	; 0x800675 <pxOverflowDelayedTaskList>
 738:	90 91 76 06 	lds	r25, 0x0676	; 0x800676 <pxOverflowDelayedTaskList+0x1>
 73c:	6e 5f       	subi	r22, 0xFE	; 254
 73e:	7f 4f       	sbci	r23, 0xFF	; 255
 740:	0e 94 7c 00 	call	0xf8	; 0xf8 <vListInsert>
 744:	17 c0       	rjmp	.+46     	; 0x774 <prvAddCurrentTaskToDelayedList+0x68>
 746:	60 91 af 06 	lds	r22, 0x06AF	; 0x8006af <pxCurrentTCB>
 74a:	70 91 b0 06 	lds	r23, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
 74e:	80 91 77 06 	lds	r24, 0x0677	; 0x800677 <pxDelayedTaskList>
 752:	90 91 78 06 	lds	r25, 0x0678	; 0x800678 <pxDelayedTaskList+0x1>
 756:	6e 5f       	subi	r22, 0xFE	; 254
 758:	7f 4f       	sbci	r23, 0xFF	; 255
 75a:	0e 94 7c 00 	call	0xf8	; 0xf8 <vListInsert>
 75e:	80 91 57 06 	lds	r24, 0x0657	; 0x800657 <xNextTaskUnblockTime>
 762:	90 91 58 06 	lds	r25, 0x0658	; 0x800658 <xNextTaskUnblockTime+0x1>
 766:	c8 17       	cp	r28, r24
 768:	d9 07       	cpc	r29, r25
 76a:	20 f4       	brcc	.+8      	; 0x774 <prvAddCurrentTaskToDelayedList+0x68>
 76c:	d0 93 58 06 	sts	0x0658, r29	; 0x800658 <xNextTaskUnblockTime+0x1>
 770:	c0 93 57 06 	sts	0x0657, r28	; 0x800657 <xNextTaskUnblockTime>
 774:	df 91       	pop	r29
 776:	cf 91       	pop	r28
 778:	08 95       	ret

0000077a <xTaskGenericCreate>:
 77a:	4f 92       	push	r4
 77c:	5f 92       	push	r5
 77e:	6f 92       	push	r6
 780:	7f 92       	push	r7
 782:	8f 92       	push	r8
 784:	9f 92       	push	r9
 786:	af 92       	push	r10
 788:	bf 92       	push	r11
 78a:	cf 92       	push	r12
 78c:	df 92       	push	r13
 78e:	ef 92       	push	r14
 790:	ff 92       	push	r15
 792:	0f 93       	push	r16
 794:	1f 93       	push	r17
 796:	cf 93       	push	r28
 798:	df 93       	push	r29
 79a:	4c 01       	movw	r8, r24
 79c:	eb 01       	movw	r28, r22
 79e:	5a 01       	movw	r10, r20
 7a0:	29 01       	movw	r4, r18
 7a2:	c1 14       	cp	r12, r1
 7a4:	d1 04       	cpc	r13, r1
 7a6:	39 f4       	brne	.+14     	; 0x7b6 <xTaskGenericCreate+0x3c>
 7a8:	ca 01       	movw	r24, r20
 7aa:	0e 94 79 02 	call	0x4f2	; 0x4f2 <pvPortMalloc>
 7ae:	6c 01       	movw	r12, r24
 7b0:	89 2b       	or	r24, r25
 7b2:	09 f4       	brne	.+2      	; 0x7b6 <xTaskGenericCreate+0x3c>
 7b4:	dc c0       	rjmp	.+440    	; 0x96e <__stack+0x10f>
 7b6:	86 e2       	ldi	r24, 0x26	; 38
 7b8:	90 e0       	ldi	r25, 0x00	; 0
 7ba:	0e 94 79 02 	call	0x4f2	; 0x4f2 <pvPortMalloc>
 7be:	3c 01       	movw	r6, r24
 7c0:	00 97       	sbiw	r24, 0x00	; 0
 7c2:	79 f0       	breq	.+30     	; 0x7e2 <xTaskGenericCreate+0x68>
 7c4:	fc 01       	movw	r30, r24
 7c6:	d0 8e       	std	Z+24, r13	; 0x18
 7c8:	c7 8a       	std	Z+23, r12	; 0x17
 7ca:	f1 e0       	ldi	r31, 0x01	; 1
 7cc:	af 1a       	sub	r10, r31
 7ce:	b1 08       	sbc	r11, r1
 7d0:	ca 0c       	add	r12, r10
 7d2:	db 1c       	adc	r13, r11
 7d4:	88 81       	ld	r24, Y
 7d6:	f3 01       	movw	r30, r6
 7d8:	81 8f       	std	Z+25, r24	; 0x19
 7da:	88 81       	ld	r24, Y
 7dc:	81 11       	cpse	r24, r1
 7de:	05 c0       	rjmp	.+10     	; 0x7ea <xTaskGenericCreate+0x70>
 7e0:	14 c0       	rjmp	.+40     	; 0x80a <xTaskGenericCreate+0x90>
 7e2:	c6 01       	movw	r24, r12
 7e4:	0e 94 35 03 	call	0x66a	; 0x66a <vPortFree>
 7e8:	c2 c0       	rjmp	.+388    	; 0x96e <__stack+0x10f>
 7ea:	d3 01       	movw	r26, r6
 7ec:	5a 96       	adiw	r26, 0x1a	; 26
 7ee:	fe 01       	movw	r30, r28
 7f0:	31 96       	adiw	r30, 0x01	; 1
 7f2:	9e 01       	movw	r18, r28
 7f4:	28 5f       	subi	r18, 0xF8	; 248
 7f6:	3f 4f       	sbci	r19, 0xFF	; 255
 7f8:	ef 01       	movw	r28, r30
 7fa:	81 91       	ld	r24, Z+
 7fc:	8d 93       	st	X+, r24
 7fe:	88 81       	ld	r24, Y
 800:	88 23       	and	r24, r24
 802:	19 f0       	breq	.+6      	; 0x80a <xTaskGenericCreate+0x90>
 804:	e2 17       	cp	r30, r18
 806:	f3 07       	cpc	r31, r19
 808:	b9 f7       	brne	.-18     	; 0x7f8 <xTaskGenericCreate+0x7e>
 80a:	f3 01       	movw	r30, r6
 80c:	10 a2       	std	Z+32, r1	; 0x20
 80e:	10 2f       	mov	r17, r16
 810:	04 30       	cpi	r16, 0x04	; 4
 812:	08 f0       	brcs	.+2      	; 0x816 <xTaskGenericCreate+0x9c>
 814:	13 e0       	ldi	r17, 0x03	; 3
 816:	f3 01       	movw	r30, r6
 818:	16 8b       	std	Z+22, r17	; 0x16
 81a:	e3 01       	movw	r28, r6
 81c:	22 96       	adiw	r28, 0x02	; 2
 81e:	ce 01       	movw	r24, r28
 820:	0e 94 57 00 	call	0xae	; 0xae <vListInitialiseItem>
 824:	c3 01       	movw	r24, r6
 826:	0c 96       	adiw	r24, 0x0c	; 12
 828:	0e 94 57 00 	call	0xae	; 0xae <vListInitialiseItem>
 82c:	f3 01       	movw	r30, r6
 82e:	71 86       	std	Z+9, r7	; 0x09
 830:	60 86       	std	Z+8, r6	; 0x08
 832:	84 e0       	ldi	r24, 0x04	; 4
 834:	90 e0       	ldi	r25, 0x00	; 0
 836:	81 1b       	sub	r24, r17
 838:	91 09       	sbc	r25, r1
 83a:	95 87       	std	Z+13, r25	; 0x0d
 83c:	84 87       	std	Z+12, r24	; 0x0c
 83e:	73 8a       	std	Z+19, r7	; 0x13
 840:	62 8a       	std	Z+18, r6	; 0x12
 842:	11 a2       	std	Z+33, r1	; 0x21
 844:	12 a2       	std	Z+34, r1	; 0x22
 846:	13 a2       	std	Z+35, r1	; 0x23
 848:	14 a2       	std	Z+36, r1	; 0x24
 84a:	15 a2       	std	Z+37, r1	; 0x25
 84c:	a2 01       	movw	r20, r4
 84e:	b4 01       	movw	r22, r8
 850:	c6 01       	movw	r24, r12
 852:	0e 94 d3 00 	call	0x1a6	; 0x1a6 <pxPortInitialiseStack>
 856:	f3 01       	movw	r30, r6
 858:	91 83       	std	Z+1, r25	; 0x01
 85a:	80 83       	st	Z, r24
 85c:	e1 14       	cp	r14, r1
 85e:	f1 04       	cpc	r15, r1
 860:	19 f0       	breq	.+6      	; 0x868 <__stack+0x9>
 862:	f7 01       	movw	r30, r14
 864:	71 82       	std	Z+1, r7	; 0x01
 866:	60 82       	st	Z, r6
 868:	0f b6       	in	r0, 0x3f	; 63
 86a:	f8 94       	cli
 86c:	0f 92       	push	r0
 86e:	80 91 61 06 	lds	r24, 0x0661	; 0x800661 <uxCurrentNumberOfTasks>
 872:	8f 5f       	subi	r24, 0xFF	; 255
 874:	80 93 61 06 	sts	0x0661, r24	; 0x800661 <uxCurrentNumberOfTasks>
 878:	80 91 af 06 	lds	r24, 0x06AF	; 0x8006af <pxCurrentTCB>
 87c:	90 91 b0 06 	lds	r25, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
 880:	89 2b       	or	r24, r25
 882:	a9 f5       	brne	.+106    	; 0x8ee <__stack+0x8f>
 884:	70 92 b0 06 	sts	0x06B0, r7	; 0x8006b0 <pxCurrentTCB+0x1>
 888:	60 92 af 06 	sts	0x06AF, r6	; 0x8006af <pxCurrentTCB>
 88c:	80 91 61 06 	lds	r24, 0x0661	; 0x800661 <uxCurrentNumberOfTasks>
 890:	81 30       	cpi	r24, 0x01	; 1
 892:	e1 f5       	brne	.+120    	; 0x90c <__stack+0xad>
 894:	8b e8       	ldi	r24, 0x8B	; 139
 896:	96 e0       	ldi	r25, 0x06	; 6
 898:	0e 94 49 00 	call	0x92	; 0x92 <vListInitialise>
 89c:	84 e9       	ldi	r24, 0x94	; 148
 89e:	96 e0       	ldi	r25, 0x06	; 6
 8a0:	0e 94 49 00 	call	0x92	; 0x92 <vListInitialise>
 8a4:	8d e9       	ldi	r24, 0x9D	; 157
 8a6:	96 e0       	ldi	r25, 0x06	; 6
 8a8:	0e 94 49 00 	call	0x92	; 0x92 <vListInitialise>
 8ac:	86 ea       	ldi	r24, 0xA6	; 166
 8ae:	96 e0       	ldi	r25, 0x06	; 6
 8b0:	0e 94 49 00 	call	0x92	; 0x92 <vListInitialise>
 8b4:	82 e8       	ldi	r24, 0x82	; 130
 8b6:	96 e0       	ldi	r25, 0x06	; 6
 8b8:	0e 94 49 00 	call	0x92	; 0x92 <vListInitialise>
 8bc:	89 e7       	ldi	r24, 0x79	; 121
 8be:	96 e0       	ldi	r25, 0x06	; 6
 8c0:	0e 94 49 00 	call	0x92	; 0x92 <vListInitialise>
 8c4:	8c e6       	ldi	r24, 0x6C	; 108
 8c6:	96 e0       	ldi	r25, 0x06	; 6
 8c8:	0e 94 49 00 	call	0x92	; 0x92 <vListInitialise>
 8cc:	83 e6       	ldi	r24, 0x63	; 99
 8ce:	96 e0       	ldi	r25, 0x06	; 6
 8d0:	0e 94 49 00 	call	0x92	; 0x92 <vListInitialise>
 8d4:	82 e8       	ldi	r24, 0x82	; 130
 8d6:	96 e0       	ldi	r25, 0x06	; 6
 8d8:	90 93 78 06 	sts	0x0678, r25	; 0x800678 <pxDelayedTaskList+0x1>
 8dc:	80 93 77 06 	sts	0x0677, r24	; 0x800677 <pxDelayedTaskList>
 8e0:	89 e7       	ldi	r24, 0x79	; 121
 8e2:	96 e0       	ldi	r25, 0x06	; 6
 8e4:	90 93 76 06 	sts	0x0676, r25	; 0x800676 <pxOverflowDelayedTaskList+0x1>
 8e8:	80 93 75 06 	sts	0x0675, r24	; 0x800675 <pxOverflowDelayedTaskList>
 8ec:	0f c0       	rjmp	.+30     	; 0x90c <__stack+0xad>
 8ee:	80 91 5d 06 	lds	r24, 0x065D	; 0x80065d <xSchedulerRunning>
 8f2:	81 11       	cpse	r24, r1
 8f4:	0b c0       	rjmp	.+22     	; 0x90c <__stack+0xad>
 8f6:	e0 91 af 06 	lds	r30, 0x06AF	; 0x8006af <pxCurrentTCB>
 8fa:	f0 91 b0 06 	lds	r31, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
 8fe:	86 89       	ldd	r24, Z+22	; 0x16
 900:	08 17       	cp	r16, r24
 902:	20 f0       	brcs	.+8      	; 0x90c <__stack+0xad>
 904:	70 92 b0 06 	sts	0x06B0, r7	; 0x8006b0 <pxCurrentTCB+0x1>
 908:	60 92 af 06 	sts	0x06AF, r6	; 0x8006af <pxCurrentTCB>
 90c:	80 91 59 06 	lds	r24, 0x0659	; 0x800659 <uxTaskNumber>
 910:	8f 5f       	subi	r24, 0xFF	; 255
 912:	80 93 59 06 	sts	0x0659, r24	; 0x800659 <uxTaskNumber>
 916:	f3 01       	movw	r30, r6
 918:	86 89       	ldd	r24, Z+22	; 0x16
 91a:	90 91 5e 06 	lds	r25, 0x065E	; 0x80065e <uxTopReadyPriority>
 91e:	98 17       	cp	r25, r24
 920:	10 f4       	brcc	.+4      	; 0x926 <__stack+0xc7>
 922:	80 93 5e 06 	sts	0x065E, r24	; 0x80065e <uxTopReadyPriority>
 926:	90 e0       	ldi	r25, 0x00	; 0
 928:	9c 01       	movw	r18, r24
 92a:	22 0f       	add	r18, r18
 92c:	33 1f       	adc	r19, r19
 92e:	22 0f       	add	r18, r18
 930:	33 1f       	adc	r19, r19
 932:	22 0f       	add	r18, r18
 934:	33 1f       	adc	r19, r19
 936:	82 0f       	add	r24, r18
 938:	93 1f       	adc	r25, r19
 93a:	be 01       	movw	r22, r28
 93c:	85 57       	subi	r24, 0x75	; 117
 93e:	99 4f       	sbci	r25, 0xF9	; 249
 940:	0e 94 5b 00 	call	0xb6	; 0xb6 <vListInsertEnd>
 944:	0f 90       	pop	r0
 946:	0f be       	out	0x3f, r0	; 63
 948:	80 91 5d 06 	lds	r24, 0x065D	; 0x80065d <xSchedulerRunning>
 94c:	88 23       	and	r24, r24
 94e:	59 f0       	breq	.+22     	; 0x966 <__stack+0x107>
 950:	e0 91 af 06 	lds	r30, 0x06AF	; 0x8006af <pxCurrentTCB>
 954:	f0 91 b0 06 	lds	r31, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
 958:	86 89       	ldd	r24, Z+22	; 0x16
 95a:	80 17       	cp	r24, r16
 95c:	30 f4       	brcc	.+12     	; 0x96a <__stack+0x10b>
 95e:	0e 94 74 01 	call	0x2e8	; 0x2e8 <vPortYield>
 962:	81 e0       	ldi	r24, 0x01	; 1
 964:	05 c0       	rjmp	.+10     	; 0x970 <__stack+0x111>
 966:	81 e0       	ldi	r24, 0x01	; 1
 968:	03 c0       	rjmp	.+6      	; 0x970 <__stack+0x111>
 96a:	81 e0       	ldi	r24, 0x01	; 1
 96c:	01 c0       	rjmp	.+2      	; 0x970 <__stack+0x111>
 96e:	8f ef       	ldi	r24, 0xFF	; 255
 970:	df 91       	pop	r29
 972:	cf 91       	pop	r28
 974:	1f 91       	pop	r17
 976:	0f 91       	pop	r16
 978:	ff 90       	pop	r15
 97a:	ef 90       	pop	r14
 97c:	df 90       	pop	r13
 97e:	cf 90       	pop	r12
 980:	bf 90       	pop	r11
 982:	af 90       	pop	r10
 984:	9f 90       	pop	r9
 986:	8f 90       	pop	r8
 988:	7f 90       	pop	r7
 98a:	6f 90       	pop	r6
 98c:	5f 90       	pop	r5
 98e:	4f 90       	pop	r4
 990:	08 95       	ret

00000992 <vTaskStartScheduler>:
 992:	af 92       	push	r10
 994:	bf 92       	push	r11
 996:	cf 92       	push	r12
 998:	df 92       	push	r13
 99a:	ef 92       	push	r14
 99c:	ff 92       	push	r15
 99e:	0f 93       	push	r16
 9a0:	a1 2c       	mov	r10, r1
 9a2:	b1 2c       	mov	r11, r1
 9a4:	c1 2c       	mov	r12, r1
 9a6:	d1 2c       	mov	r13, r1
 9a8:	e1 2c       	mov	r14, r1
 9aa:	f1 2c       	mov	r15, r1
 9ac:	00 e0       	ldi	r16, 0x00	; 0
 9ae:	20 e0       	ldi	r18, 0x00	; 0
 9b0:	30 e0       	ldi	r19, 0x00	; 0
 9b2:	45 e5       	ldi	r20, 0x55	; 85
 9b4:	50 e0       	ldi	r21, 0x00	; 0
 9b6:	60 e6       	ldi	r22, 0x60	; 96
 9b8:	70 e0       	ldi	r23, 0x00	; 0
 9ba:	80 e6       	ldi	r24, 0x60	; 96
 9bc:	96 e0       	ldi	r25, 0x06	; 6
 9be:	0e 94 bd 03 	call	0x77a	; 0x77a <xTaskGenericCreate>
 9c2:	81 30       	cpi	r24, 0x01	; 1
 9c4:	81 f4       	brne	.+32     	; 0x9e6 <vTaskStartScheduler+0x54>
 9c6:	f8 94       	cli
 9c8:	8f ef       	ldi	r24, 0xFF	; 255
 9ca:	9f ef       	ldi	r25, 0xFF	; 255
 9cc:	90 93 58 06 	sts	0x0658, r25	; 0x800658 <xNextTaskUnblockTime+0x1>
 9d0:	80 93 57 06 	sts	0x0657, r24	; 0x800657 <xNextTaskUnblockTime>
 9d4:	81 e0       	ldi	r24, 0x01	; 1
 9d6:	80 93 5d 06 	sts	0x065D, r24	; 0x80065d <xSchedulerRunning>
 9da:	10 92 60 06 	sts	0x0660, r1	; 0x800660 <xTickCount+0x1>
 9de:	10 92 5f 06 	sts	0x065F, r1	; 0x80065f <xTickCount>
 9e2:	0e 94 3f 01 	call	0x27e	; 0x27e <xPortStartScheduler>
 9e6:	0f 91       	pop	r16
 9e8:	ff 90       	pop	r15
 9ea:	ef 90       	pop	r14
 9ec:	df 90       	pop	r13
 9ee:	cf 90       	pop	r12
 9f0:	bf 90       	pop	r11
 9f2:	af 90       	pop	r10
 9f4:	08 95       	ret

000009f6 <vTaskSuspendAll>:
 9f6:	80 91 56 06 	lds	r24, 0x0656	; 0x800656 <uxSchedulerSuspended>
 9fa:	8f 5f       	subi	r24, 0xFF	; 255
 9fc:	80 93 56 06 	sts	0x0656, r24	; 0x800656 <uxSchedulerSuspended>
 a00:	08 95       	ret

00000a02 <xTaskIncrementTick>:
 a02:	cf 92       	push	r12
 a04:	df 92       	push	r13
 a06:	ef 92       	push	r14
 a08:	ff 92       	push	r15
 a0a:	0f 93       	push	r16
 a0c:	1f 93       	push	r17
 a0e:	cf 93       	push	r28
 a10:	df 93       	push	r29
 a12:	80 91 56 06 	lds	r24, 0x0656	; 0x800656 <uxSchedulerSuspended>
 a16:	81 11       	cpse	r24, r1
 a18:	9b c0       	rjmp	.+310    	; 0xb50 <xTaskIncrementTick+0x14e>
 a1a:	80 91 5f 06 	lds	r24, 0x065F	; 0x80065f <xTickCount>
 a1e:	90 91 60 06 	lds	r25, 0x0660	; 0x800660 <xTickCount+0x1>
 a22:	01 96       	adiw	r24, 0x01	; 1
 a24:	90 93 60 06 	sts	0x0660, r25	; 0x800660 <xTickCount+0x1>
 a28:	80 93 5f 06 	sts	0x065F, r24	; 0x80065f <xTickCount>
 a2c:	e0 90 5f 06 	lds	r14, 0x065F	; 0x80065f <xTickCount>
 a30:	f0 90 60 06 	lds	r15, 0x0660	; 0x800660 <xTickCount+0x1>
 a34:	e1 14       	cp	r14, r1
 a36:	f1 04       	cpc	r15, r1
 a38:	b9 f4       	brne	.+46     	; 0xa68 <xTaskIncrementTick+0x66>
 a3a:	80 91 77 06 	lds	r24, 0x0677	; 0x800677 <pxDelayedTaskList>
 a3e:	90 91 78 06 	lds	r25, 0x0678	; 0x800678 <pxDelayedTaskList+0x1>
 a42:	20 91 75 06 	lds	r18, 0x0675	; 0x800675 <pxOverflowDelayedTaskList>
 a46:	30 91 76 06 	lds	r19, 0x0676	; 0x800676 <pxOverflowDelayedTaskList+0x1>
 a4a:	30 93 78 06 	sts	0x0678, r19	; 0x800678 <pxDelayedTaskList+0x1>
 a4e:	20 93 77 06 	sts	0x0677, r18	; 0x800677 <pxDelayedTaskList>
 a52:	90 93 76 06 	sts	0x0676, r25	; 0x800676 <pxOverflowDelayedTaskList+0x1>
 a56:	80 93 75 06 	sts	0x0675, r24	; 0x800675 <pxOverflowDelayedTaskList>
 a5a:	80 91 5a 06 	lds	r24, 0x065A	; 0x80065a <xNumOfOverflows>
 a5e:	8f 5f       	subi	r24, 0xFF	; 255
 a60:	80 93 5a 06 	sts	0x065A, r24	; 0x80065a <xNumOfOverflows>
 a64:	0e 94 67 03 	call	0x6ce	; 0x6ce <prvResetNextTaskUnblockTime>
 a68:	80 91 57 06 	lds	r24, 0x0657	; 0x800657 <xNextTaskUnblockTime>
 a6c:	90 91 58 06 	lds	r25, 0x0658	; 0x800658 <xNextTaskUnblockTime+0x1>
 a70:	e8 16       	cp	r14, r24
 a72:	f9 06       	cpc	r15, r25
 a74:	10 f4       	brcc	.+4      	; 0xa7a <xTaskIncrementTick+0x78>
 a76:	d1 2c       	mov	r13, r1
 a78:	53 c0       	rjmp	.+166    	; 0xb20 <xTaskIncrementTick+0x11e>
 a7a:	d1 2c       	mov	r13, r1
 a7c:	cc 24       	eor	r12, r12
 a7e:	c3 94       	inc	r12
 a80:	e0 91 77 06 	lds	r30, 0x0677	; 0x800677 <pxDelayedTaskList>
 a84:	f0 91 78 06 	lds	r31, 0x0678	; 0x800678 <pxDelayedTaskList+0x1>
 a88:	80 81       	ld	r24, Z
 a8a:	81 11       	cpse	r24, r1
 a8c:	07 c0       	rjmp	.+14     	; 0xa9c <xTaskIncrementTick+0x9a>
 a8e:	8f ef       	ldi	r24, 0xFF	; 255
 a90:	9f ef       	ldi	r25, 0xFF	; 255
 a92:	90 93 58 06 	sts	0x0658, r25	; 0x800658 <xNextTaskUnblockTime+0x1>
 a96:	80 93 57 06 	sts	0x0657, r24	; 0x800657 <xNextTaskUnblockTime>
 a9a:	42 c0       	rjmp	.+132    	; 0xb20 <xTaskIncrementTick+0x11e>
 a9c:	e0 91 77 06 	lds	r30, 0x0677	; 0x800677 <pxDelayedTaskList>
 aa0:	f0 91 78 06 	lds	r31, 0x0678	; 0x800678 <pxDelayedTaskList+0x1>
 aa4:	05 80       	ldd	r0, Z+5	; 0x05
 aa6:	f6 81       	ldd	r31, Z+6	; 0x06
 aa8:	e0 2d       	mov	r30, r0
 aaa:	c6 81       	ldd	r28, Z+6	; 0x06
 aac:	d7 81       	ldd	r29, Z+7	; 0x07
 aae:	8a 81       	ldd	r24, Y+2	; 0x02
 ab0:	9b 81       	ldd	r25, Y+3	; 0x03
 ab2:	e8 16       	cp	r14, r24
 ab4:	f9 06       	cpc	r15, r25
 ab6:	28 f4       	brcc	.+10     	; 0xac2 <xTaskIncrementTick+0xc0>
 ab8:	90 93 58 06 	sts	0x0658, r25	; 0x800658 <xNextTaskUnblockTime+0x1>
 abc:	80 93 57 06 	sts	0x0657, r24	; 0x800657 <xNextTaskUnblockTime>
 ac0:	2f c0       	rjmp	.+94     	; 0xb20 <xTaskIncrementTick+0x11e>
 ac2:	8e 01       	movw	r16, r28
 ac4:	0e 5f       	subi	r16, 0xFE	; 254
 ac6:	1f 4f       	sbci	r17, 0xFF	; 255
 ac8:	c8 01       	movw	r24, r16
 aca:	0e 94 ad 00 	call	0x15a	; 0x15a <uxListRemove>
 ace:	8c 89       	ldd	r24, Y+20	; 0x14
 ad0:	9d 89       	ldd	r25, Y+21	; 0x15
 ad2:	89 2b       	or	r24, r25
 ad4:	21 f0       	breq	.+8      	; 0xade <xTaskIncrementTick+0xdc>
 ad6:	ce 01       	movw	r24, r28
 ad8:	0c 96       	adiw	r24, 0x0c	; 12
 ada:	0e 94 ad 00 	call	0x15a	; 0x15a <uxListRemove>
 ade:	8e 89       	ldd	r24, Y+22	; 0x16
 ae0:	90 91 5e 06 	lds	r25, 0x065E	; 0x80065e <uxTopReadyPriority>
 ae4:	98 17       	cp	r25, r24
 ae6:	10 f4       	brcc	.+4      	; 0xaec <xTaskIncrementTick+0xea>
 ae8:	80 93 5e 06 	sts	0x065E, r24	; 0x80065e <uxTopReadyPriority>
 aec:	90 e0       	ldi	r25, 0x00	; 0
 aee:	9c 01       	movw	r18, r24
 af0:	22 0f       	add	r18, r18
 af2:	33 1f       	adc	r19, r19
 af4:	22 0f       	add	r18, r18
 af6:	33 1f       	adc	r19, r19
 af8:	22 0f       	add	r18, r18
 afa:	33 1f       	adc	r19, r19
 afc:	82 0f       	add	r24, r18
 afe:	93 1f       	adc	r25, r19
 b00:	b8 01       	movw	r22, r16
 b02:	85 57       	subi	r24, 0x75	; 117
 b04:	99 4f       	sbci	r25, 0xF9	; 249
 b06:	0e 94 5b 00 	call	0xb6	; 0xb6 <vListInsertEnd>
 b0a:	e0 91 af 06 	lds	r30, 0x06AF	; 0x8006af <pxCurrentTCB>
 b0e:	f0 91 b0 06 	lds	r31, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
 b12:	9e 89       	ldd	r25, Y+22	; 0x16
 b14:	86 89       	ldd	r24, Z+22	; 0x16
 b16:	98 17       	cp	r25, r24
 b18:	08 f4       	brcc	.+2      	; 0xb1c <xTaskIncrementTick+0x11a>
 b1a:	b2 cf       	rjmp	.-156    	; 0xa80 <xTaskIncrementTick+0x7e>
 b1c:	dc 2c       	mov	r13, r12
 b1e:	b0 cf       	rjmp	.-160    	; 0xa80 <xTaskIncrementTick+0x7e>
 b20:	e0 91 af 06 	lds	r30, 0x06AF	; 0x8006af <pxCurrentTCB>
 b24:	f0 91 b0 06 	lds	r31, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
 b28:	86 89       	ldd	r24, Z+22	; 0x16
 b2a:	90 e0       	ldi	r25, 0x00	; 0
 b2c:	fc 01       	movw	r30, r24
 b2e:	ee 0f       	add	r30, r30
 b30:	ff 1f       	adc	r31, r31
 b32:	ee 0f       	add	r30, r30
 b34:	ff 1f       	adc	r31, r31
 b36:	ee 0f       	add	r30, r30
 b38:	ff 1f       	adc	r31, r31
 b3a:	8e 0f       	add	r24, r30
 b3c:	9f 1f       	adc	r25, r31
 b3e:	fc 01       	movw	r30, r24
 b40:	e5 57       	subi	r30, 0x75	; 117
 b42:	f9 4f       	sbci	r31, 0xF9	; 249
 b44:	80 81       	ld	r24, Z
 b46:	82 30       	cpi	r24, 0x02	; 2
 b48:	48 f0       	brcs	.+18     	; 0xb5c <xTaskIncrementTick+0x15a>
 b4a:	dd 24       	eor	r13, r13
 b4c:	d3 94       	inc	r13
 b4e:	06 c0       	rjmp	.+12     	; 0xb5c <xTaskIncrementTick+0x15a>
 b50:	80 91 5c 06 	lds	r24, 0x065C	; 0x80065c <uxPendedTicks>
 b54:	8f 5f       	subi	r24, 0xFF	; 255
 b56:	80 93 5c 06 	sts	0x065C, r24	; 0x80065c <uxPendedTicks>
 b5a:	d1 2c       	mov	r13, r1
 b5c:	80 91 5b 06 	lds	r24, 0x065B	; 0x80065b <xYieldPending>
 b60:	88 23       	and	r24, r24
 b62:	11 f0       	breq	.+4      	; 0xb68 <xTaskIncrementTick+0x166>
 b64:	dd 24       	eor	r13, r13
 b66:	d3 94       	inc	r13
 b68:	8d 2d       	mov	r24, r13
 b6a:	df 91       	pop	r29
 b6c:	cf 91       	pop	r28
 b6e:	1f 91       	pop	r17
 b70:	0f 91       	pop	r16
 b72:	ff 90       	pop	r15
 b74:	ef 90       	pop	r14
 b76:	df 90       	pop	r13
 b78:	cf 90       	pop	r12
 b7a:	08 95       	ret

00000b7c <xTaskResumeAll>:
 b7c:	df 92       	push	r13
 b7e:	ef 92       	push	r14
 b80:	ff 92       	push	r15
 b82:	0f 93       	push	r16
 b84:	1f 93       	push	r17
 b86:	cf 93       	push	r28
 b88:	df 93       	push	r29
 b8a:	0f b6       	in	r0, 0x3f	; 63
 b8c:	f8 94       	cli
 b8e:	0f 92       	push	r0
 b90:	80 91 56 06 	lds	r24, 0x0656	; 0x800656 <uxSchedulerSuspended>
 b94:	81 50       	subi	r24, 0x01	; 1
 b96:	80 93 56 06 	sts	0x0656, r24	; 0x800656 <uxSchedulerSuspended>
 b9a:	80 91 56 06 	lds	r24, 0x0656	; 0x800656 <uxSchedulerSuspended>
 b9e:	81 11       	cpse	r24, r1
 ba0:	62 c0       	rjmp	.+196    	; 0xc66 <xTaskResumeAll+0xea>
 ba2:	80 91 61 06 	lds	r24, 0x0661	; 0x800661 <uxCurrentNumberOfTasks>
 ba6:	81 11       	cpse	r24, r1
 ba8:	33 c0       	rjmp	.+102    	; 0xc10 <xTaskResumeAll+0x94>
 baa:	60 c0       	rjmp	.+192    	; 0xc6c <xTaskResumeAll+0xf0>
 bac:	d7 01       	movw	r26, r14
 bae:	15 96       	adiw	r26, 0x05	; 5
 bb0:	ed 91       	ld	r30, X+
 bb2:	fc 91       	ld	r31, X
 bb4:	16 97       	sbiw	r26, 0x06	; 6
 bb6:	c6 81       	ldd	r28, Z+6	; 0x06
 bb8:	d7 81       	ldd	r29, Z+7	; 0x07
 bba:	ce 01       	movw	r24, r28
 bbc:	0c 96       	adiw	r24, 0x0c	; 12
 bbe:	0e 94 ad 00 	call	0x15a	; 0x15a <uxListRemove>
 bc2:	8e 01       	movw	r16, r28
 bc4:	0e 5f       	subi	r16, 0xFE	; 254
 bc6:	1f 4f       	sbci	r17, 0xFF	; 255
 bc8:	c8 01       	movw	r24, r16
 bca:	0e 94 ad 00 	call	0x15a	; 0x15a <uxListRemove>
 bce:	8e 89       	ldd	r24, Y+22	; 0x16
 bd0:	90 91 5e 06 	lds	r25, 0x065E	; 0x80065e <uxTopReadyPriority>
 bd4:	98 17       	cp	r25, r24
 bd6:	10 f4       	brcc	.+4      	; 0xbdc <xTaskResumeAll+0x60>
 bd8:	80 93 5e 06 	sts	0x065E, r24	; 0x80065e <uxTopReadyPriority>
 bdc:	90 e0       	ldi	r25, 0x00	; 0
 bde:	9c 01       	movw	r18, r24
 be0:	22 0f       	add	r18, r18
 be2:	33 1f       	adc	r19, r19
 be4:	22 0f       	add	r18, r18
 be6:	33 1f       	adc	r19, r19
 be8:	22 0f       	add	r18, r18
 bea:	33 1f       	adc	r19, r19
 bec:	82 0f       	add	r24, r18
 bee:	93 1f       	adc	r25, r19
 bf0:	b8 01       	movw	r22, r16
 bf2:	85 57       	subi	r24, 0x75	; 117
 bf4:	99 4f       	sbci	r25, 0xF9	; 249
 bf6:	0e 94 5b 00 	call	0xb6	; 0xb6 <vListInsertEnd>
 bfa:	e0 91 af 06 	lds	r30, 0x06AF	; 0x8006af <pxCurrentTCB>
 bfe:	f0 91 b0 06 	lds	r31, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
 c02:	9e 89       	ldd	r25, Y+22	; 0x16
 c04:	86 89       	ldd	r24, Z+22	; 0x16
 c06:	98 17       	cp	r25, r24
 c08:	58 f0       	brcs	.+22     	; 0xc20 <xTaskResumeAll+0xa4>
 c0a:	d0 92 5b 06 	sts	0x065B, r13	; 0x80065b <xYieldPending>
 c0e:	08 c0       	rjmp	.+16     	; 0xc20 <xTaskResumeAll+0xa4>
 c10:	0f 2e       	mov	r0, r31
 c12:	fc e6       	ldi	r31, 0x6C	; 108
 c14:	ef 2e       	mov	r14, r31
 c16:	f6 e0       	ldi	r31, 0x06	; 6
 c18:	ff 2e       	mov	r15, r31
 c1a:	f0 2d       	mov	r31, r0
 c1c:	dd 24       	eor	r13, r13
 c1e:	d3 94       	inc	r13
 c20:	f7 01       	movw	r30, r14
 c22:	80 81       	ld	r24, Z
 c24:	81 11       	cpse	r24, r1
 c26:	c2 cf       	rjmp	.-124    	; 0xbac <xTaskResumeAll+0x30>
 c28:	80 91 5c 06 	lds	r24, 0x065C	; 0x80065c <uxPendedTicks>
 c2c:	88 23       	and	r24, r24
 c2e:	99 f0       	breq	.+38     	; 0xc56 <xTaskResumeAll+0xda>
 c30:	80 91 5c 06 	lds	r24, 0x065C	; 0x80065c <uxPendedTicks>
 c34:	88 23       	and	r24, r24
 c36:	79 f0       	breq	.+30     	; 0xc56 <xTaskResumeAll+0xda>
 c38:	c1 e0       	ldi	r28, 0x01	; 1
 c3a:	0e 94 01 05 	call	0xa02	; 0xa02 <xTaskIncrementTick>
 c3e:	81 11       	cpse	r24, r1
 c40:	c0 93 5b 06 	sts	0x065B, r28	; 0x80065b <xYieldPending>
 c44:	80 91 5c 06 	lds	r24, 0x065C	; 0x80065c <uxPendedTicks>
 c48:	81 50       	subi	r24, 0x01	; 1
 c4a:	80 93 5c 06 	sts	0x065C, r24	; 0x80065c <uxPendedTicks>
 c4e:	80 91 5c 06 	lds	r24, 0x065C	; 0x80065c <uxPendedTicks>
 c52:	81 11       	cpse	r24, r1
 c54:	f2 cf       	rjmp	.-28     	; 0xc3a <xTaskResumeAll+0xbe>
 c56:	80 91 5b 06 	lds	r24, 0x065B	; 0x80065b <xYieldPending>
 c5a:	81 30       	cpi	r24, 0x01	; 1
 c5c:	31 f4       	brne	.+12     	; 0xc6a <xTaskResumeAll+0xee>
 c5e:	0e 94 74 01 	call	0x2e8	; 0x2e8 <vPortYield>
 c62:	81 e0       	ldi	r24, 0x01	; 1
 c64:	03 c0       	rjmp	.+6      	; 0xc6c <xTaskResumeAll+0xf0>
 c66:	80 e0       	ldi	r24, 0x00	; 0
 c68:	01 c0       	rjmp	.+2      	; 0xc6c <xTaskResumeAll+0xf0>
 c6a:	80 e0       	ldi	r24, 0x00	; 0
 c6c:	0f 90       	pop	r0
 c6e:	0f be       	out	0x3f, r0	; 63
 c70:	df 91       	pop	r29
 c72:	cf 91       	pop	r28
 c74:	1f 91       	pop	r17
 c76:	0f 91       	pop	r16
 c78:	ff 90       	pop	r15
 c7a:	ef 90       	pop	r14
 c7c:	df 90       	pop	r13
 c7e:	08 95       	ret

00000c80 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 c80:	cf 93       	push	r28
 c82:	df 93       	push	r29
 c84:	ec 01       	movw	r28, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 c86:	89 2b       	or	r24, r25
 c88:	b1 f0       	breq	.+44     	; 0xcb6 <vTaskDelay+0x36>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
 c8a:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 c8e:	80 91 5f 06 	lds	r24, 0x065F	; 0x80065f <xTickCount>
 c92:	90 91 60 06 	lds	r25, 0x0660	; 0x800660 <xTickCount+0x1>
 c96:	c8 0f       	add	r28, r24
 c98:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 c9a:	80 91 af 06 	lds	r24, 0x06AF	; 0x8006af <pxCurrentTCB>
 c9e:	90 91 b0 06 	lds	r25, 0x06B0	; 0x8006b0 <pxCurrentTCB+0x1>
 ca2:	02 96       	adiw	r24, 0x02	; 2
 ca4:	0e 94 ad 00 	call	0x15a	; 0x15a <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
 ca8:	ce 01       	movw	r24, r28
 caa:	0e 94 86 03 	call	0x70c	; 0x70c <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 cae:	0e 94 be 05 	call	0xb7c	; 0xb7c <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 cb2:	81 11       	cpse	r24, r1
 cb4:	02 c0       	rjmp	.+4      	; 0xcba <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
 cb6:	0e 94 74 01 	call	0x2e8	; 0x2e8 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 cba:	df 91       	pop	r29
 cbc:	cf 91       	pop	r28
 cbe:	08 95       	ret

00000cc0 <prvIdleTask>:
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 cc0:	03 e6       	ldi	r16, 0x63	; 99
 cc2:	16 e0       	ldi	r17, 0x06	; 6

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 cc4:	0f 2e       	mov	r0, r31
 cc6:	fb e8       	ldi	r31, 0x8B	; 139
 cc8:	ef 2e       	mov	r14, r31
 cca:	f6 e0       	ldi	r31, 0x06	; 6
 ccc:	ff 2e       	mov	r15, r31
 cce:	f0 2d       	mov	r31, r0
 cd0:	29 c0       	rjmp	.+82     	; 0xd24 <prvIdleTask+0x64>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
 cd2:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 cd6:	d8 01       	movw	r26, r16
 cd8:	cc 91       	ld	r28, X
			}
			( void ) xTaskResumeAll();
 cda:	0e 94 be 05 	call	0xb7c	; 0xb7c <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 cde:	cc 23       	and	r28, r28
 ce0:	09 f1       	breq	.+66     	; 0xd24 <prvIdleTask+0x64>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
 ce2:	0f b6       	in	r0, 0x3f	; 63
 ce4:	f8 94       	cli
 ce6:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 ce8:	d8 01       	movw	r26, r16
 cea:	15 96       	adiw	r26, 0x05	; 5
 cec:	ed 91       	ld	r30, X+
 cee:	fc 91       	ld	r31, X
 cf0:	16 97       	sbiw	r26, 0x06	; 6
 cf2:	c6 81       	ldd	r28, Z+6	; 0x06
 cf4:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 cf6:	ce 01       	movw	r24, r28
 cf8:	02 96       	adiw	r24, 0x02	; 2
 cfa:	0e 94 ad 00 	call	0x15a	; 0x15a <uxListRemove>
					--uxCurrentNumberOfTasks;
 cfe:	80 91 61 06 	lds	r24, 0x0661	; 0x800661 <uxCurrentNumberOfTasks>
 d02:	81 50       	subi	r24, 0x01	; 1
 d04:	80 93 61 06 	sts	0x0661, r24	; 0x800661 <uxCurrentNumberOfTasks>
					--uxTasksDeleted;
 d08:	80 91 62 06 	lds	r24, 0x0662	; 0x800662 <uxTasksDeleted>
 d0c:	81 50       	subi	r24, 0x01	; 1
 d0e:	80 93 62 06 	sts	0x0662, r24	; 0x800662 <uxTasksDeleted>
				}
				taskEXIT_CRITICAL();
 d12:	0f 90       	pop	r0
 d14:	0f be       	out	0x3f, r0	; 63
				vPortFreeAligned( pxTCB->pxStack );
			}
		}
		#else
		{
			vPortFreeAligned( pxTCB->pxStack );
 d16:	8f 89       	ldd	r24, Y+23	; 0x17
 d18:	98 8d       	ldd	r25, Y+24	; 0x18
 d1a:	0e 94 35 03 	call	0x66a	; 0x66a <vPortFree>
		}
		#endif

		vPortFree( pxTCB );
 d1e:	ce 01       	movw	r24, r28
 d20:	0e 94 35 03 	call	0x66a	; 0x66a <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
 d24:	80 91 62 06 	lds	r24, 0x0662	; 0x800662 <uxTasksDeleted>
 d28:	81 11       	cpse	r24, r1
 d2a:	d3 cf       	rjmp	.-90     	; 0xcd2 <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 d2c:	f7 01       	movw	r30, r14
 d2e:	80 81       	ld	r24, Z
 d30:	82 30       	cpi	r24, 0x02	; 2
 d32:	c0 f3       	brcs	.-16     	; 0xd24 <prvIdleTask+0x64>
			{
				taskYIELD();
 d34:	0e 94 74 01 	call	0x2e8	; 0x2e8 <vPortYield>
 d38:	f5 cf       	rjmp	.-22     	; 0xd24 <prvIdleTask+0x64>

00000d3a <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 d3a:	80 91 56 06 	lds	r24, 0x0656	; 0x800656 <uxSchedulerSuspended>
 d3e:	88 23       	and	r24, r24
 d40:	21 f0       	breq	.+8      	; 0xd4a <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 d42:	81 e0       	ldi	r24, 0x01	; 1
 d44:	80 93 5b 06 	sts	0x065B, r24	; 0x80065b <xYieldPending>
 d48:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
 d4a:	10 92 5b 06 	sts	0x065B, r1	; 0x80065b <xYieldPending>
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 d4e:	80 91 5e 06 	lds	r24, 0x065E	; 0x80065e <uxTopReadyPriority>
 d52:	90 e0       	ldi	r25, 0x00	; 0
 d54:	fc 01       	movw	r30, r24
 d56:	ee 0f       	add	r30, r30
 d58:	ff 1f       	adc	r31, r31
 d5a:	ee 0f       	add	r30, r30
 d5c:	ff 1f       	adc	r31, r31
 d5e:	ee 0f       	add	r30, r30
 d60:	ff 1f       	adc	r31, r31
 d62:	8e 0f       	add	r24, r30
 d64:	9f 1f       	adc	r25, r31
 d66:	fc 01       	movw	r30, r24
 d68:	e5 57       	subi	r30, 0x75	; 117
 d6a:	f9 4f       	sbci	r31, 0xF9	; 249
 d6c:	80 81       	ld	r24, Z
 d6e:	81 11       	cpse	r24, r1
 d70:	17 c0       	rjmp	.+46     	; 0xda0 <vTaskSwitchContext+0x66>
 d72:	80 91 5e 06 	lds	r24, 0x065E	; 0x80065e <uxTopReadyPriority>
 d76:	81 50       	subi	r24, 0x01	; 1
 d78:	80 93 5e 06 	sts	0x065E, r24	; 0x80065e <uxTopReadyPriority>
 d7c:	80 91 5e 06 	lds	r24, 0x065E	; 0x80065e <uxTopReadyPriority>
 d80:	90 e0       	ldi	r25, 0x00	; 0
 d82:	fc 01       	movw	r30, r24
 d84:	ee 0f       	add	r30, r30
 d86:	ff 1f       	adc	r31, r31
 d88:	ee 0f       	add	r30, r30
 d8a:	ff 1f       	adc	r31, r31
 d8c:	ee 0f       	add	r30, r30
 d8e:	ff 1f       	adc	r31, r31
 d90:	8e 0f       	add	r24, r30
 d92:	9f 1f       	adc	r25, r31
 d94:	fc 01       	movw	r30, r24
 d96:	e5 57       	subi	r30, 0x75	; 117
 d98:	f9 4f       	sbci	r31, 0xF9	; 249
 d9a:	80 81       	ld	r24, Z
 d9c:	88 23       	and	r24, r24
 d9e:	49 f3       	breq	.-46     	; 0xd72 <vTaskSwitchContext+0x38>
 da0:	80 91 5e 06 	lds	r24, 0x065E	; 0x80065e <uxTopReadyPriority>
 da4:	90 e0       	ldi	r25, 0x00	; 0
 da6:	9c 01       	movw	r18, r24
 da8:	22 0f       	add	r18, r18
 daa:	33 1f       	adc	r19, r19
 dac:	22 0f       	add	r18, r18
 dae:	33 1f       	adc	r19, r19
 db0:	22 0f       	add	r18, r18
 db2:	33 1f       	adc	r19, r19
 db4:	28 0f       	add	r18, r24
 db6:	39 1f       	adc	r19, r25
 db8:	d9 01       	movw	r26, r18
 dba:	a5 57       	subi	r26, 0x75	; 117
 dbc:	b9 4f       	sbci	r27, 0xF9	; 249
 dbe:	11 96       	adiw	r26, 0x01	; 1
 dc0:	ed 91       	ld	r30, X+
 dc2:	fc 91       	ld	r31, X
 dc4:	12 97       	sbiw	r26, 0x02	; 2
 dc6:	02 80       	ldd	r0, Z+2	; 0x02
 dc8:	f3 81       	ldd	r31, Z+3	; 0x03
 dca:	e0 2d       	mov	r30, r0
 dcc:	12 96       	adiw	r26, 0x02	; 2
 dce:	fc 93       	st	X, r31
 dd0:	ee 93       	st	-X, r30
 dd2:	11 97       	sbiw	r26, 0x01	; 1
 dd4:	22 57       	subi	r18, 0x72	; 114
 dd6:	39 4f       	sbci	r19, 0xF9	; 249
 dd8:	e2 17       	cp	r30, r18
 dda:	f3 07       	cpc	r31, r19
 ddc:	29 f4       	brne	.+10     	; 0xde8 <vTaskSwitchContext+0xae>
 dde:	22 81       	ldd	r18, Z+2	; 0x02
 de0:	33 81       	ldd	r19, Z+3	; 0x03
 de2:	fd 01       	movw	r30, r26
 de4:	32 83       	std	Z+2, r19	; 0x02
 de6:	21 83       	std	Z+1, r18	; 0x01
 de8:	fc 01       	movw	r30, r24
 dea:	ee 0f       	add	r30, r30
 dec:	ff 1f       	adc	r31, r31
 dee:	ee 0f       	add	r30, r30
 df0:	ff 1f       	adc	r31, r31
 df2:	ee 0f       	add	r30, r30
 df4:	ff 1f       	adc	r31, r31
 df6:	8e 0f       	add	r24, r30
 df8:	9f 1f       	adc	r25, r31
 dfa:	fc 01       	movw	r30, r24
 dfc:	e5 57       	subi	r30, 0x75	; 117
 dfe:	f9 4f       	sbci	r31, 0xF9	; 249
 e00:	01 80       	ldd	r0, Z+1	; 0x01
 e02:	f2 81       	ldd	r31, Z+2	; 0x02
 e04:	e0 2d       	mov	r30, r0
 e06:	86 81       	ldd	r24, Z+6	; 0x06
 e08:	97 81       	ldd	r25, Z+7	; 0x07
 e0a:	90 93 b0 06 	sts	0x06B0, r25	; 0x8006b0 <pxCurrentTCB+0x1>
 e0e:	80 93 af 06 	sts	0x06AF, r24	; 0x8006af <pxCurrentTCB>
 e12:	08 95       	ret

00000e14 <Task1>:
}


void Task1(void *p){
	
	DDRA |= (1<<1);
 e14:	d1 9a       	sbi	0x1a, 1	; 26
	
	for(;;){
		
		PORTA ^= (1<<1);
 e16:	c2 e0       	ldi	r28, 0x02	; 2
 e18:	8b b3       	in	r24, 0x1b	; 27
 e1a:	8c 27       	eor	r24, r28
 e1c:	8b bb       	out	0x1b, r24	; 27
		vTaskDelay(100);
 e1e:	84 e6       	ldi	r24, 0x64	; 100
 e20:	90 e0       	ldi	r25, 0x00	; 0
 e22:	0e 94 40 06 	call	0xc80	; 0xc80 <vTaskDelay>
 e26:	f8 cf       	rjmp	.-16     	; 0xe18 <Task1+0x4>

00000e28 <main>:
TaskHandle_t task1_Handle = NULL;
void Task1(void *p);

int main(void)
{
	xTaskCreate(Task1, "mytask1", 90,(void *) 0, 1, &task1_Handle);
 e28:	a1 2c       	mov	r10, r1
 e2a:	b1 2c       	mov	r11, r1
 e2c:	c1 2c       	mov	r12, r1
 e2e:	d1 2c       	mov	r13, r1
 e30:	0f 2e       	mov	r0, r31
 e32:	f1 eb       	ldi	r31, 0xB1	; 177
 e34:	ef 2e       	mov	r14, r31
 e36:	f6 e0       	ldi	r31, 0x06	; 6
 e38:	ff 2e       	mov	r15, r31
 e3a:	f0 2d       	mov	r31, r0
 e3c:	01 e0       	ldi	r16, 0x01	; 1
 e3e:	20 e0       	ldi	r18, 0x00	; 0
 e40:	30 e0       	ldi	r19, 0x00	; 0
 e42:	4a e5       	ldi	r20, 0x5A	; 90
 e44:	50 e0       	ldi	r21, 0x00	; 0
 e46:	65 e6       	ldi	r22, 0x65	; 101
 e48:	70 e0       	ldi	r23, 0x00	; 0
 e4a:	8a e0       	ldi	r24, 0x0A	; 10
 e4c:	97 e0       	ldi	r25, 0x07	; 7
 e4e:	0e 94 bd 03 	call	0x77a	; 0x77a <xTaskGenericCreate>
	vTaskStartScheduler();
 e52:	0e 94 c9 04 	call	0x992	; 0x992 <vTaskStartScheduler>
 e56:	ff cf       	rjmp	.-2      	; 0xe56 <main+0x2e>

00000e58 <_exit>:
 e58:	f8 94       	cli

00000e5a <__stop_program>:
 e5a:	ff cf       	rjmp	.-2      	; 0xe5a <__stop_program>
